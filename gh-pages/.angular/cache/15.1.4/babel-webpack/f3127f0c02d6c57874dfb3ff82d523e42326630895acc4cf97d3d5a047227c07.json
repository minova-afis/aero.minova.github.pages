{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, Pipe, InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, EventEmitter, Input, Output, SecurityContext, NgModule } from '@angular/core';\nimport { Subject, merge, of, timer } from 'rxjs';\nimport { switchMap, mapTo, distinctUntilChanged, shareReplay, startWith, map, takeUntil, first } from 'rxjs/operators';\nimport * as i1 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { Renderer, marked } from 'marked';\nexport { Renderer as MarkedRenderer } from 'marked';\nimport * as i1$1 from '@angular/common/http';\nimport * as i4 from '@angular/platform-browser';\nconst _c0 = [\"*\"];\nconst BUTTON_TEXT_COPY = 'Copy';\nconst BUTTON_TEXT_COPIED = 'Copied';\nlet ClipboardButtonComponent = /*#__PURE__*/(() => {\n  class ClipboardButtonComponent {\n    constructor() {\n      this._buttonClick$ = new Subject();\n      this.copied$ = this._buttonClick$.pipe(switchMap(() => merge(of(true), timer(3000).pipe(mapTo(false)))), distinctUntilChanged(), shareReplay(1));\n      this.copiedText$ = this.copied$.pipe(startWith(false), map(copied => copied ? BUTTON_TEXT_COPIED : BUTTON_TEXT_COPY));\n    }\n    onCopyToClipboardClick() {\n      this._buttonClick$.next();\n    }\n  }\n  ClipboardButtonComponent.ɵfac = function ClipboardButtonComponent_Factory(t) {\n    return new (t || ClipboardButtonComponent)();\n  };\n  ClipboardButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ClipboardButtonComponent,\n    selectors: [[\"markdown-clipboard\"]],\n    decls: 4,\n    vars: 7,\n    consts: [[1, \"markdown-clipboard-button\", 3, \"click\"]],\n    template: function ClipboardButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"button\", 0);\n        i0.ɵɵlistener(\"click\", function ClipboardButtonComponent_Template_button_click_0_listener() {\n          return ctx.onCopyToClipboardClick();\n        });\n        i0.ɵɵpipe(1, \"async\");\n        i0.ɵɵtext(2);\n        i0.ɵɵpipe(3, \"async\");\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"copied\", i0.ɵɵpipeBind1(1, 3, ctx.copied$));\n        i0.ɵɵadvance(2);\n        i0.ɵɵtextInterpolate(i0.ɵɵpipeBind1(3, 5, ctx.copiedText$));\n      }\n    },\n    dependencies: [i1.AsyncPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return ClipboardButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass ClipboardOptions {}\nclass ClipboardRenderOptions extends ClipboardOptions {}\n\n/* eslint-disable */\nclass KatexSpecificOptions {}\nlet LanguagePipe = /*#__PURE__*/(() => {\n  class LanguagePipe {\n    transform(value, language) {\n      if (value == null) {\n        value = '';\n      }\n      if (language == null) {\n        language = '';\n      }\n      if (typeof value !== 'string') {\n        console.error(`LanguagePipe has been invoked with an invalid value type [${typeof value}]`);\n        return value;\n      }\n      if (typeof language !== 'string') {\n        console.error(`LanguagePipe has been invoked with an invalid parameter [${typeof language}]`);\n        return value;\n      }\n      return '```' + language + '\\n' + value + '\\n```';\n    }\n  }\n  LanguagePipe.ɵfac = function LanguagePipe_Factory(t) {\n    return new (t || LanguagePipe)();\n  };\n  LanguagePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"language\",\n    type: LanguagePipe,\n    pure: true\n  });\n  return LanguagePipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar PrismPlugin = /*#__PURE__*/(() => {\n  (function (PrismPlugin) {\n    PrismPlugin[\"CommandLine\"] = \"command-line\";\n    PrismPlugin[\"LineHighlight\"] = \"line-highlight\";\n    PrismPlugin[\"LineNumbers\"] = \"line-numbers\";\n  })(PrismPlugin || (PrismPlugin = {}));\n  return PrismPlugin;\n})();\nclass MarkedOptions {}\n\n/* eslint-disable max-len */\nconst errorJoyPixelsNotLoaded = '[ngx-markdown] When using the `emoji` attribute you *have to* include Emoji-Toolkit files to `angular.json` or use imports. See README for more information';\nconst errorKatexNotLoaded = '[ngx-markdown] When using the `katex` attribute you *have to* include KaTeX files to `angular.json` or use imports. See README for more information';\nconst errorMermaidNotLoaded = '[ngx-markdown] When using the `mermaid` attribute you *have to* include Mermaid files to `angular.json` or use imports. See README for more information';\nconst errorClipboardNotLoaded = '[ngx-markdown] When using the `clipboard` attribute you *have to* include Clipboard files to `angular.json` or use imports. See README for more information';\nconst errorClipboardViewContainerRequired = '[ngx-markdown] When using the `clipboard` attribute you *have to* provide the `viewContainerRef` parameter to `MarkdownService.render()` function';\nconst errorSrcWithoutHttpClient = '[ngx-markdown] When using the `src` attribute you *have to* pass the `HttpClient` as a parameter of the `forRoot` method. See README for more information';\n/* eslint-enable max-len */\nconst SECURITY_CONTEXT = new InjectionToken('SECURITY_CONTEXT');\nclass ExtendedRenderer extends Renderer {\n  constructor() {\n    super(...arguments);\n    this.ɵNgxMarkdownRendererExtended = false;\n  }\n}\nlet MarkdownService = /*#__PURE__*/(() => {\n  class MarkdownService {\n    constructor(platform, securityContext, http, clipboardOptions, options, sanitizer) {\n      this.platform = platform;\n      this.securityContext = securityContext;\n      this.http = http;\n      this.clipboardOptions = clipboardOptions;\n      this.sanitizer = sanitizer;\n      this.DEFAULT_MARKED_OPTIONS = {\n        renderer: new Renderer()\n      };\n      this.DEFAULT_KATEX_OPTIONS = {\n        delimiters: [{\n          left: \"$$\",\n          right: \"$$\",\n          display: true\n        }, {\n          left: \"$\",\n          right: \"$\",\n          display: false\n        }, {\n          left: \"\\\\(\",\n          right: \"\\\\)\",\n          display: false\n        }, {\n          left: \"\\\\begin{equation}\",\n          right: \"\\\\end{equation}\",\n          display: true\n        }, {\n          left: \"\\\\begin{align}\",\n          right: \"\\\\end{align}\",\n          display: true\n        }, {\n          left: \"\\\\begin{alignat}\",\n          right: \"\\\\end{alignat}\",\n          display: true\n        }, {\n          left: \"\\\\begin{gather}\",\n          right: \"\\\\end{gather}\",\n          display: true\n        }, {\n          left: \"\\\\begin{CD}\",\n          right: \"\\\\end{CD}\",\n          display: true\n        }, {\n          left: \"\\\\[\",\n          right: \"\\\\]\",\n          display: true\n        }]\n      };\n      this.DEFAULT_MERMAID_OPTIONS = {\n        startOnLoad: false\n      };\n      this.DEFAULT_CLIPBOARD_OPTIONS = {\n        buttonComponent: undefined\n      };\n      this.DEFAULT_PARSE_OPTIONS = {\n        decodeHtml: false,\n        inline: false,\n        emoji: false,\n        mermaid: false,\n        markedOptions: this.DEFAULT_MARKED_OPTIONS,\n        disableSanitizer: false\n      };\n      this.DEFAULT_RENDER_OPTIONS = {\n        clipboard: false,\n        clipboardOptions: undefined,\n        katex: false,\n        katexOptions: undefined,\n        mermaid: false,\n        mermaidOptions: undefined\n      };\n      this._reload$ = new Subject();\n      this.reload$ = this._reload$.asObservable();\n      this.options = options;\n    }\n    get options() {\n      return this._options;\n    }\n    set options(value) {\n      this._options = {\n        ...this.DEFAULT_MARKED_OPTIONS,\n        ...value\n      };\n    }\n    get renderer() {\n      return this.options.renderer;\n    }\n    set renderer(value) {\n      this.options.renderer = value;\n    }\n    parse(markdown, parseOptions = this.DEFAULT_PARSE_OPTIONS) {\n      const {\n        decodeHtml,\n        inline,\n        emoji,\n        mermaid,\n        disableSanitizer\n      } = parseOptions;\n      const markedOptions = {\n        ...this.options,\n        ...parseOptions.markedOptions\n      };\n      if (mermaid) {\n        this.renderer = this.extendRenderer(markedOptions.renderer || new Renderer());\n      }\n      const trimmed = this.trimIndentation(markdown);\n      const decoded = decodeHtml ? this.decodeHtml(trimmed) : trimmed;\n      const emojified = emoji ? this.parseEmoji(decoded) : decoded;\n      const marked = this.parseMarked(emojified, markedOptions, inline);\n      const sanitized = disableSanitizer ? marked : this.sanitizer.sanitize(this.securityContext, marked);\n      return sanitized || '';\n    }\n    render(element, options = this.DEFAULT_RENDER_OPTIONS, viewContainerRef) {\n      const {\n        clipboard,\n        clipboardOptions,\n        katex,\n        katexOptions,\n        mermaid,\n        mermaidOptions\n      } = options;\n      if (clipboard) {\n        this.renderClipboard(element, viewContainerRef, {\n          ...this.DEFAULT_CLIPBOARD_OPTIONS,\n          ...this.clipboardOptions,\n          ...clipboardOptions\n        });\n      }\n      if (katex) {\n        this.renderKatex(element, {\n          ...this.DEFAULT_KATEX_OPTIONS,\n          ...katexOptions\n        });\n      }\n      if (mermaid) {\n        this.renderMermaid(element, {\n          ...this.DEFAULT_MERMAID_OPTIONS,\n          ...mermaidOptions\n        });\n      }\n      this.highlight(element);\n    }\n    reload() {\n      this._reload$.next();\n    }\n    getSource(src) {\n      if (!this.http) {\n        throw new Error(errorSrcWithoutHttpClient);\n      }\n      return this.http.get(src, {\n        responseType: 'text'\n      }).pipe(map(markdown => this.handleExtension(src, markdown)));\n    }\n    highlight(element) {\n      if (!isPlatformBrowser(this.platform)) {\n        return;\n      }\n      if (typeof Prism === 'undefined' || typeof Prism.highlightAllUnder === 'undefined') {\n        return;\n      }\n      if (!element) {\n        element = document;\n      }\n      const noLanguageElements = element.querySelectorAll('pre code:not([class*=\"language-\"])');\n      Array.prototype.forEach.call(noLanguageElements, x => x.classList.add('language-none'));\n      Prism.highlightAllUnder(element);\n    }\n    decodeHtml(html) {\n      if (!isPlatformBrowser(this.platform)) {\n        return html;\n      }\n      const textarea = document.createElement('textarea');\n      textarea.innerHTML = html;\n      return textarea.value;\n    }\n    extendRenderer(renderer) {\n      const extendedRenderer = renderer;\n      if (extendedRenderer.ɵNgxMarkdownRendererExtended === true) {\n        return renderer;\n      }\n      // eslint-disable-next-line @typescript-eslint/unbound-method\n      const defaultCode = renderer.code;\n      renderer.code = function (code, language, isEscaped) {\n        return language === 'mermaid' ? `<div class=\"mermaid\">${code}</div>` : defaultCode.call(this, code, language, isEscaped);\n      };\n      extendedRenderer.ɵNgxMarkdownRendererExtended = true;\n      return renderer;\n    }\n    handleExtension(src, markdown) {\n      const urlProtocolIndex = src.lastIndexOf('://');\n      const urlWithoutProtocol = urlProtocolIndex > -1 ? src.substring(urlProtocolIndex + 4) : src;\n      const lastSlashIndex = urlWithoutProtocol.lastIndexOf('/');\n      const lastUrlSegment = lastSlashIndex > -1 ? urlWithoutProtocol.substring(lastSlashIndex + 1).split('?')[0] : '';\n      const lastDotIndex = lastUrlSegment.lastIndexOf('.');\n      const extension = lastDotIndex > -1 ? lastUrlSegment.substring(lastDotIndex + 1) : '';\n      return !!extension && extension !== 'md' ? '```' + extension + '\\n' + markdown + '\\n```' : markdown;\n    }\n    parseMarked(html, markedOptions, inline = false) {\n      if (!isPlatformBrowser(this.platform)) {\n        return html;\n      }\n      if (inline) {\n        return marked.parseInline(html, markedOptions);\n      }\n      return marked.parse(html, markedOptions);\n    }\n    parseEmoji(html) {\n      if (!isPlatformBrowser(this.platform)) {\n        return html;\n      }\n      if (typeof joypixels === 'undefined' || typeof joypixels.shortnameToUnicode === 'undefined') {\n        throw new Error(errorJoyPixelsNotLoaded);\n      }\n      return joypixels.shortnameToUnicode(html);\n    }\n    renderKatex(element, options) {\n      if (!isPlatformBrowser(this.platform)) {\n        return;\n      }\n      if (typeof katex === 'undefined' || typeof renderMathInElement === 'undefined') {\n        throw new Error(errorKatexNotLoaded);\n      }\n      renderMathInElement(element, options);\n    }\n    renderClipboard(element, viewContainerRef, options) {\n      if (!isPlatformBrowser(this.platform)) {\n        return;\n      }\n      if (typeof ClipboardJS === 'undefined') {\n        throw new Error(errorClipboardNotLoaded);\n      }\n      if (!viewContainerRef) {\n        throw new Error(errorClipboardViewContainerRequired);\n      }\n      const {\n        buttonComponent,\n        buttonTemplate\n      } = options;\n      // target every <pre> elements\n      const preElements = element.querySelectorAll('pre');\n      for (let i = 0; i < preElements.length; i++) {\n        const preElement = preElements.item(i);\n        // create <pre> wrapper element\n        const preWrapperElement = document.createElement('div');\n        preWrapperElement.style.position = 'relative';\n        preElement.parentNode.insertBefore(preWrapperElement, preElement);\n        preWrapperElement.appendChild(preElement);\n        // create toolbar element\n        const toolbarWrapperElement = document.createElement('div');\n        toolbarWrapperElement.style.position = 'absolute';\n        toolbarWrapperElement.style.top = '.5em';\n        toolbarWrapperElement.style.right = '.5em';\n        toolbarWrapperElement.style.opacity = '0';\n        toolbarWrapperElement.style.transition = 'opacity 250ms ease-out';\n        preWrapperElement.insertAdjacentElement('beforeend', toolbarWrapperElement);\n        // register listener to show/hide toolbar\n        preElement.onmouseover = () => toolbarWrapperElement.style.opacity = '1';\n        preElement.onmouseout = () => toolbarWrapperElement.style.opacity = '0';\n        // declare embeddedViewRef holding variable\n        let embeddedViewRef;\n        // use provided component via input property\n        // or provided via ClipboardOptions provider\n        if (buttonComponent) {\n          const componentRef = viewContainerRef.createComponent(buttonComponent);\n          embeddedViewRef = componentRef.hostView;\n        }\n        // use provided template via input property\n        else if (buttonTemplate) {\n          embeddedViewRef = viewContainerRef.createEmbeddedView(buttonTemplate);\n        }\n        // use default component\n        else {\n          const componentRef = viewContainerRef.createComponent(ClipboardButtonComponent);\n          embeddedViewRef = componentRef.hostView;\n        }\n        // declare clipboard instance variable\n        let clipboardInstance;\n        // attach clipboard.js to root node\n        embeddedViewRef.rootNodes.forEach(node => {\n          node.onmouseover = () => toolbarWrapperElement.style.opacity = '1';\n          toolbarWrapperElement.appendChild(node);\n          clipboardInstance = new ClipboardJS(node, {\n            text: () => preElement.innerText\n          });\n        });\n        // destroy clipboard instance when view is destroyed\n        embeddedViewRef.onDestroy(() => clipboardInstance.destroy());\n      }\n    }\n    renderMermaid(element, options = this.DEFAULT_MERMAID_OPTIONS) {\n      if (!isPlatformBrowser(this.platform)) {\n        return;\n      }\n      if (typeof mermaid === 'undefined' || typeof mermaid.init === 'undefined') {\n        throw new Error(errorMermaidNotLoaded);\n      }\n      const mermaidElements = element.querySelectorAll('.mermaid');\n      if (mermaidElements.length === 0) {\n        return;\n      }\n      mermaid.initialize(options);\n      mermaid.init(mermaidElements);\n    }\n    trimIndentation(markdown) {\n      if (!markdown) {\n        return '';\n      }\n      let indentStart;\n      return markdown.split('\\n').map(line => {\n        let lineIdentStart = indentStart;\n        if (line.length > 0) {\n          lineIdentStart = isNaN(lineIdentStart) ? line.search(/\\S|$/) : Math.min(line.search(/\\S|$/), lineIdentStart);\n        }\n        if (isNaN(indentStart)) {\n          indentStart = lineIdentStart;\n        }\n        return lineIdentStart ? line.substring(lineIdentStart) : line;\n      }).join('\\n');\n    }\n  }\n  MarkdownService.ɵfac = function MarkdownService_Factory(t) {\n    return new (t || MarkdownService)(i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(SECURITY_CONTEXT), i0.ɵɵinject(i1$1.HttpClient, 8), i0.ɵɵinject(ClipboardOptions, 8), i0.ɵɵinject(MarkedOptions, 8), i0.ɵɵinject(i4.DomSanitizer));\n  };\n  MarkdownService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: MarkdownService,\n    factory: MarkdownService.ɵfac\n  });\n  return MarkdownService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nlet MarkdownComponent = /*#__PURE__*/(() => {\n  class MarkdownComponent {\n    constructor(element, markdownService, viewContainerRef) {\n      this.element = element;\n      this.markdownService = markdownService;\n      this.viewContainerRef = viewContainerRef;\n      // Event emitters\n      this.error = new EventEmitter();\n      this.load = new EventEmitter();\n      this.ready = new EventEmitter();\n      this._clipboard = false;\n      this._commandLine = false;\n      this._disableSanitizer = false;\n      this._emoji = false;\n      this._inline = false;\n      this._katex = false;\n      this._lineHighlight = false;\n      this._lineNumbers = false;\n      this._mermaid = false;\n      this._srcRelativeLink = false;\n      this.destroyed$ = new Subject();\n    }\n    get disableSanitizer() {\n      return this._disableSanitizer;\n    }\n    set disableSanitizer(value) {\n      this._disableSanitizer = this.coerceBooleanProperty(value);\n    }\n    get inline() {\n      return this._inline;\n    }\n    set inline(value) {\n      this._inline = this.coerceBooleanProperty(value);\n    }\n    get srcRelativeLink() {\n      return this._srcRelativeLink;\n    }\n    set srcRelativeLink(value) {\n      this._srcRelativeLink = this.coerceBooleanProperty(value);\n    }\n    // Plugin - clipboard\n    get clipboard() {\n      return this._clipboard;\n    }\n    set clipboard(value) {\n      this._clipboard = this.coerceBooleanProperty(value);\n    }\n    // Plugin - emoji\n    get emoji() {\n      return this._emoji;\n    }\n    set emoji(value) {\n      this._emoji = this.coerceBooleanProperty(value);\n    }\n    // Plugin - katex\n    get katex() {\n      return this._katex;\n    }\n    set katex(value) {\n      this._katex = this.coerceBooleanProperty(value);\n    }\n    // Plugin - mermaid\n    get mermaid() {\n      return this._mermaid;\n    }\n    set mermaid(value) {\n      this._mermaid = this.coerceBooleanProperty(value);\n    }\n    // Plugin - lineHighlight\n    get lineHighlight() {\n      return this._lineHighlight;\n    }\n    set lineHighlight(value) {\n      this._lineHighlight = this.coerceBooleanProperty(value);\n    }\n    // Plugin - lineNumbers\n    get lineNumbers() {\n      return this._lineNumbers;\n    }\n    set lineNumbers(value) {\n      this._lineNumbers = this.coerceBooleanProperty(value);\n    }\n    // Plugin - commandLine\n    get commandLine() {\n      return this._commandLine;\n    }\n    set commandLine(value) {\n      this._commandLine = this.coerceBooleanProperty(value);\n    }\n    ngOnChanges() {\n      this.loadContent();\n    }\n    loadContent() {\n      if (this.data != null) {\n        this.handleData();\n        return;\n      }\n      if (this.src != null) {\n        this.handleSrc();\n        return;\n      }\n    }\n    ngAfterViewInit() {\n      if (!this.data && !this.src) {\n        this.handleTransclusion();\n      }\n      this.markdownService.reload$.pipe(takeUntil(this.destroyed$)).subscribe(() => this.loadContent());\n    }\n    ngOnDestroy() {\n      this.destroyed$.next();\n      this.destroyed$.complete();\n    }\n    render(markdown, decodeHtml = false) {\n      let markedOptions;\n      if (this.src && this.srcRelativeLink) {\n        const baseUrl = new URL(this.src, location.origin).pathname;\n        markedOptions = {\n          baseUrl\n        };\n      }\n      const parsedOptions = {\n        decodeHtml,\n        inline: this.inline,\n        emoji: this.emoji,\n        mermaid: this.mermaid,\n        markedOptions,\n        disableSanitizer: this.disableSanitizer\n      };\n      const renderOptions = {\n        clipboard: this.clipboard,\n        clipboardOptions: {\n          buttonComponent: this.clipboardButtonComponent,\n          buttonTemplate: this.clipboardButtonTemplate\n        },\n        katex: this.katex,\n        katexOptions: this.katexOptions,\n        mermaid: this.mermaid,\n        mermaidOptions: this.mermaidOptions\n      };\n      const parsed = this.markdownService.parse(markdown, parsedOptions);\n      this.element.nativeElement.innerHTML = parsed;\n      this.handlePlugins();\n      this.markdownService.render(this.element.nativeElement, renderOptions, this.viewContainerRef);\n      this.ready.emit();\n    }\n    coerceBooleanProperty(value) {\n      return value != null && `${String(value)}` !== 'false';\n    }\n    handleData() {\n      this.render(this.data);\n    }\n    handleSrc() {\n      this.markdownService.getSource(this.src).subscribe({\n        next: markdown => {\n          this.render(markdown);\n          this.load.emit(markdown);\n        },\n        error: error => this.error.emit(error)\n      });\n    }\n    handleTransclusion() {\n      this.render(this.element.nativeElement.innerHTML, true);\n    }\n    handlePlugins() {\n      if (this.commandLine) {\n        this.setPluginClass(this.element.nativeElement, PrismPlugin.CommandLine);\n        this.setPluginOptions(this.element.nativeElement, {\n          dataFilterOutput: this.filterOutput,\n          dataHost: this.host,\n          dataPrompt: this.prompt,\n          dataOutput: this.output,\n          dataUser: this.user\n        });\n      }\n      if (this.lineHighlight) {\n        this.setPluginOptions(this.element.nativeElement, {\n          dataLine: this.line,\n          dataLineOffset: this.lineOffset\n        });\n      }\n      if (this.lineNumbers) {\n        this.setPluginClass(this.element.nativeElement, PrismPlugin.LineNumbers);\n        this.setPluginOptions(this.element.nativeElement, {\n          dataStart: this.start\n        });\n      }\n    }\n    setPluginClass(element, plugin) {\n      const preElements = element.querySelectorAll('pre');\n      for (let i = 0; i < preElements.length; i++) {\n        const classes = plugin instanceof Array ? plugin : [plugin];\n        preElements.item(i).classList.add(...classes);\n      }\n    }\n    setPluginOptions(element, options) {\n      const preElements = element.querySelectorAll('pre');\n      for (let i = 0; i < preElements.length; i++) {\n        Object.keys(options).forEach(option => {\n          const attributeValue = options[option];\n          if (attributeValue) {\n            const attributeName = this.toLispCase(option);\n            preElements.item(i).setAttribute(attributeName, attributeValue.toString());\n          }\n        });\n      }\n    }\n    toLispCase(value) {\n      const upperChars = value.match(/([A-Z])/g);\n      if (!upperChars) {\n        return value;\n      }\n      let str = value.toString();\n      for (let i = 0, n = upperChars.length; i < n; i++) {\n        str = str.replace(new RegExp(upperChars[i]), '-' + upperChars[i].toLowerCase());\n      }\n      if (str.slice(0, 1) === '-') {\n        str = str.slice(1);\n      }\n      return str;\n    }\n  }\n  MarkdownComponent.ɵfac = function MarkdownComponent_Factory(t) {\n    return new (t || MarkdownComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(MarkdownService), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  MarkdownComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: MarkdownComponent,\n    selectors: [[\"markdown\"], [\"\", \"markdown\", \"\"]],\n    inputs: {\n      data: \"data\",\n      src: \"src\",\n      disableSanitizer: \"disableSanitizer\",\n      inline: \"inline\",\n      srcRelativeLink: \"srcRelativeLink\",\n      clipboard: \"clipboard\",\n      clipboardButtonComponent: \"clipboardButtonComponent\",\n      clipboardButtonTemplate: \"clipboardButtonTemplate\",\n      emoji: \"emoji\",\n      katex: \"katex\",\n      katexOptions: \"katexOptions\",\n      mermaid: \"mermaid\",\n      mermaidOptions: \"mermaidOptions\",\n      lineHighlight: \"lineHighlight\",\n      line: \"line\",\n      lineOffset: \"lineOffset\",\n      lineNumbers: \"lineNumbers\",\n      start: \"start\",\n      commandLine: \"commandLine\",\n      filterOutput: \"filterOutput\",\n      host: \"host\",\n      prompt: \"prompt\",\n      output: \"output\",\n      user: \"user\"\n    },\n    outputs: {\n      error: \"error\",\n      load: \"load\",\n      ready: \"ready\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function MarkdownComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return MarkdownComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MarkdownPipe = /*#__PURE__*/(() => {\n  class MarkdownPipe {\n    constructor(domSanitizer, elementRef, markdownService, viewContainerRef, zone) {\n      this.domSanitizer = domSanitizer;\n      this.elementRef = elementRef;\n      this.markdownService = markdownService;\n      this.viewContainerRef = viewContainerRef;\n      this.zone = zone;\n    }\n    transform(value, options) {\n      if (value == null) {\n        return '';\n      }\n      if (typeof value !== 'string') {\n        console.error(`MarkdownPipe has been invoked with an invalid value type [${typeof value}]`);\n        return value;\n      }\n      const markdown = this.markdownService.parse(value, options);\n      this.zone.onStable.pipe(first()).subscribe(() => this.markdownService.render(this.elementRef.nativeElement, options, this.viewContainerRef));\n      return this.domSanitizer.bypassSecurityTrustHtml(markdown);\n    }\n  }\n  MarkdownPipe.ɵfac = function MarkdownPipe_Factory(t) {\n    return new (t || MarkdownPipe)(i0.ɵɵdirectiveInject(i4.DomSanitizer, 16), i0.ɵɵdirectiveInject(i0.ElementRef, 16), i0.ɵɵdirectiveInject(MarkdownService, 16), i0.ɵɵdirectiveInject(i0.ViewContainerRef, 16), i0.ɵɵdirectiveInject(i0.NgZone, 16));\n  };\n  MarkdownPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"markdown\",\n    type: MarkdownPipe,\n    pure: true\n  });\n  return MarkdownPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst sharedDeclarations = [ClipboardButtonComponent, LanguagePipe, MarkdownComponent, MarkdownPipe];\nconst sharedEntryComponents = [ClipboardButtonComponent];\nlet MarkdownModule = /*#__PURE__*/(() => {\n  class MarkdownModule {\n    static forRoot(markdownModuleConfig) {\n      return {\n        ngModule: MarkdownModule,\n        providers: [MarkdownService, markdownModuleConfig && markdownModuleConfig.loader || [], markdownModuleConfig && markdownModuleConfig.clipboardOptions || [], markdownModuleConfig && markdownModuleConfig.markedOptions || [], {\n          provide: SECURITY_CONTEXT,\n          useValue: markdownModuleConfig && markdownModuleConfig.sanitize != null ? markdownModuleConfig.sanitize : SecurityContext.HTML\n        }]\n      };\n    }\n    static forChild() {\n      return {\n        ngModule: MarkdownModule\n      };\n    }\n  }\n  MarkdownModule.ɵfac = function MarkdownModule_Factory(t) {\n    return new (t || MarkdownModule)();\n  };\n  MarkdownModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: MarkdownModule\n  });\n  MarkdownModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return MarkdownModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/* eslint-disable */\nvar MermaidAPI;\n(function (MermaidAPI) {\n  let SecurityLevel;\n  (function (SecurityLevel) {\n    /**\r\n     * (default) tags in text are encoded, click functionality is disabled\r\n     */\n    SecurityLevel[\"Strict\"] = \"strict\";\n    /**\r\n     * tags in text are allowed, click functionality is enabled\r\n     */\n    SecurityLevel[\"Loose\"] = \"loose\";\n    /**\r\n     * html tags in text are allowed, (only script element is removed), click functionality is enabled\r\n     */\n    SecurityLevel[\"Antiscript\"] = \"antiscript\";\n    /**\r\n     * with this security level all rendering takes place in a sandboxed iframe.\r\n     * This prevent any javascript running in the context.\r\n     * This may hinder interactive functionality of the diagram like scripts,\r\n     * popups in sequence diagram or links to other tabs/targets etc.\r\n     */\n    SecurityLevel[\"Sandbox\"] = \"sandbox\";\n  })(SecurityLevel = MermaidAPI.SecurityLevel || (MermaidAPI.SecurityLevel = {}));\n  let Theme;\n  (function (Theme) {\n    /**\r\n     * Designed to modified, as the name implies it is supposed to be used as the base for making custom themes.\r\n     */\n    Theme[\"Base\"] = \"base\";\n    /**\r\n     * A theme full of light greens that is easy on the eyes.\r\n     */\n    Theme[\"Forest\"] = \"forest\";\n    /**\r\n     * A theme that would go well with other dark colored elements.\r\n     */\n    Theme[\"Dark\"] = \"dark\";\n    /**\r\n     *  The default theme for all diagrams.\r\n     */\n    Theme[\"Default\"] = \"default\";\n    /**\r\n     * The theme to be used for black and white printing\r\n     */\n    Theme[\"Neutral\"] = \"neutral\";\n  })(Theme = MermaidAPI.Theme || (MermaidAPI.Theme = {}));\n  let LogLevel;\n  (function (LogLevel) {\n    LogLevel[LogLevel[\"Debug\"] = 1] = \"Debug\";\n    LogLevel[LogLevel[\"Info\"] = 2] = \"Info\";\n    LogLevel[LogLevel[\"Warn\"] = 3] = \"Warn\";\n    LogLevel[LogLevel[\"Error\"] = 4] = \"Error\";\n    LogLevel[LogLevel[\"Fatal\"] = 5] = \"Fatal\";\n  })(LogLevel = MermaidAPI.LogLevel || (MermaidAPI.LogLevel = {}));\n})(MermaidAPI || (MermaidAPI = {}));\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\nexport { ClipboardButtonComponent, ClipboardOptions, ClipboardRenderOptions, ExtendedRenderer, KatexSpecificOptions, LanguagePipe, MarkdownComponent, MarkdownModule, MarkdownPipe, MarkdownService, MarkedOptions, MermaidAPI, PrismPlugin, SECURITY_CONTEXT, errorClipboardNotLoaded, errorClipboardViewContainerRequired, errorJoyPixelsNotLoaded, errorKatexNotLoaded, errorMermaidNotLoaded, errorSrcWithoutHttpClient };\n//# sourceMappingURL=ngx-markdown.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}